# 2-3D-Kinetic-Sculpture

https://github.com/user-attachments/assets/4653ffc2-c36a-4697-af6a-dc434efd6b28

### 1. การสร้างและจัดการรูปทรง (Geometry & Grid System)
ในฟังก์ชัน `main` ส่วนของ Loop การวาดภาพ เราเปลี่ยนจากการวาดกล่องเพียง 10 กล่องที่ตำแหน่งตายตัว มาเป็นการสร้าง **ตาราง (Grid)** ขนาด 10x10 แทน
*   **Nested Loops**: ใช้ `for` loop ซ้อนกัน 2 ชั้น (แกน `x` และ `z`) เพื่อวางตำแหน่งกล่องให้กระจายตัวเต็มพื้นที่พื้น
*   **Spacing**: ตัวแปร `spacing` หรือการคูณค่า `x * 1.2f` ช่วยให้กล่องแต่ละใบมีระยะห่างที่เหมาะสม ไม่ซ้อนทับกันจนเกินไป

### 2. หลักการเคลื่อนไหว (Animation Logic)
หัวใจสำคัญของ Kinetic Sculpture คือการใช้คณิตศาสตร์ตรีโกณมิติ (Trigonometry) และเวลา (`Time`) มากำหนดการเคลื่อนที่:
*   **Wave Effect (คลื่น)**:
```cpp
float yOffset = sin(glfwGetTime() * 2.0f + x * 0.5f + z* 0.5f) * 1.5f;
```
    ใช้ฟังก์ชัน `sin()` ผสมกับ `glfwGetTime()` (เวลาปัจจุบัน) เพื่อให้ค่าความสูง (`yOffset`) เปลี่ยนแปลงขึ้นลงตลอดเวลา การบวกค่า `x` และ `z` เข้าไปในสูตรทำให้แต่ละกล่องขยับ "เหลื่อมล้ำ" กัน เกิดเป็นภาพคลื่นที่วิ่งผ่านตาราง
*   **Dynamic Rotation & Scaling**:
    *   มีการหมุนกล่อง (`glm::rotate`) ตามเวลา เพื่อให้ดูมีการเคลื่อนไหวที่ซับซ้อนขึ้น
    *   มีการยืดหดขนาดกล่อง (`glm::scale`) ตามความสูง (`yOffset`) ทำให้กล่องที่ลอยสูงขึ้นดูยืดตัวออก เหมือนสปริงหรือยางยืด

### 3. ระบบแสงเงา (Advanced Lighting)
โค้ดนี้ได้รับการอัปเกรดจากแค่แสดง Texture เป็นการคำนวณแสงแบบ **Phong Lighting Model** ที่ซับซ้อนขึ้น:
*   **Normals (เวกเตอร์ตั้งฉาก)**: ใน `vertices[]` เราได้เพิ่มข้อมูลชุดที่ 2 คือ Normal Vector (เช่น `0.0f, 0.0f, -1.0f`) ซึ่งจำเป็นมากสำหรับการคำนวณว่าแสงตกกระทบพื้นผิวทำมุมเท่าไหร่ เพื่อให้เกิดเงาที่ถูกต้อง
*   **Multiple Light Sources (แหล่งกำเนิดแสงหลายจุด)**:
    *   **Directional Light**: แสงทิศทางเดียว (เหมือนแสงอาทิตย์) ให้แสงสว่างภาพรวมจางๆ
    *   **Point Lights (4 จุด)**: แสงจุด 4 สี (ขาว, แดง, น้ำเงิน, เขียว) วางกระจายรอบฉาก แสงเหล่านี้จะมีระยะตกกระทบ (Attenuation) คือยิ่งไกลแสงยิ่งจางลง

### 4. การทำงานของ Shader (Vertex & Fragment)
*   **Vertex Shader (`.vs`)**:
    *   รับค่า `aPos` (ตำแหน่ง) และ `aNormal` (ทิศทางผิว)
    *   ส่งค่า `FragPos` (ตำแหน่งจริงในโลก) และ `Normal` ที่แปลงด้วย `Normal Matrix` ไปยัง Fragment Shader เพื่อให้แสงคำนวณได้ถูกต้องแม้มีการหมุนหรือย่อขยายวัตถุ
*   **Fragment Shader (`.fs`)**:
    *   รับค่าตำแหน่งและ Normal
    *   วน Loop คำนวณผลรวมของแสงจากทุกแหล่ง (1 Directional + 4 Point Lights)
    *   รวมเอาค่า Ambient (แสงรอบด้าน), Diffuse (แสงตกกระทบ), และ Specular (แสงสะท้อนวาว) เข้าด้วยกัน แล้วผสมกับสีของ Texture (`container.jpg`) เพื่อได้สีสุดท้ายของพิกเซล
